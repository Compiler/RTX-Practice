#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

layout (std430, binding=2) buffer shader_data
{ 
  vec4 camera_position;
};

uniform precise float u_delta_x;
uniform precise float u_delta_y;
uniform precise float u_delta_z;


uint rngState;
precise float rand(vec2 co);
vec3 random();
vec3 random_in_unit_sphere();
uint wang_hash(inout uint seed);
precise float RandomFloat01(inout uint state);
vec3 RandomUnitVector(inout uint state);

struct Sphere{
  vec3 center;
  vec3 color;
  precise float radius;
  vec3 emissive;


};

struct Ray{
  vec3 origin;
  vec3 direction;

};

#define MAX_OBJECTS 4
#define MAX_RAY_DEPTH 50
#define NO_HIT_COLOR vec4(0.3, 0.3, 0.4, 1)
#define MISSED_RAY 1000000000
struct World{
  Sphere[MAX_OBJECTS] spheres;

};

struct HitRecord{
  vec3 collisionPoint;
  vec3 collisionNormal;
  precise float dist;
  bool frontFacing;
  vec3 albedo;
  vec3 emissive;


};
World world;


bool hitSphere(Ray ray, inout HitRecord record, Sphere sphere){
  precise float t = dot(sphere.center-ray.origin, ray.direction);
  vec3 collisionPoint = ray.origin + ray.direction*t;

  precise float y = length(sphere.center-collisionPoint);
  if(y < sphere.radius){
    float x = sqrt(sphere.radius*sphere.radius - y*y);
    float t1 = t-x;
    float t2 = t+x;
    if(t1 > 0.001 && t1 < MISSED_RAY){
      collisionPoint = ray.origin + ray.direction*t1;
      vec3 N = collisionPoint - sphere.center;
      record.collisionNormal = normalize(collisionPoint - sphere.center);
      record.collisionPoint = collisionPoint;
      record.dist = t;
      record.frontFacing = dot(ray.direction, record.collisionNormal) < 0;
      if(!record.frontFacing) record.collisionNormal = -record.collisionNormal;
      record.albedo = sphere.color;
      record.emissive = sphere.emissive;
    }
    else if(t2 > 0.001 && t2 < MISSED_RAY){
    t1 = t2;
      collisionPoint = ray.origin + ray.direction*t1;
      vec3 N = collisionPoint - sphere.center;
      record.collisionNormal = normalize(collisionPoint - sphere.center);
      record.collisionPoint = collisionPoint;
      record.dist = t;
      record.frontFacing = dot(ray.direction, record.collisionNormal) < 0;
      if(!record.frontFacing) record.collisionNormal = -record.collisionNormal;
      record.albedo = sphere.color;
      record.emissive = sphere.emissive;
    }
  }
  // vec3 unit_direction = ray.direction / length(ray.direction);
  // t = 0.5*(unit_direction.y + 1.0);
  // pixel = vec4((1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0), 1);
  //record.albedo = vec3(0);
  return false;
}



void initWorld(){ 
  precise float rad = 0.5;
  precise float spacing = 1;
  int count = 1;
  Sphere sphere;
  sphere.center = vec3(2 - spacing * count++, 0, 4);
  sphere.radius = rad; 
  sphere.color = vec3(0,0.7,0);
  sphere.emissive = vec3(0.0f, 0.0f, 0.0f);

  Sphere sphere2;
  sphere2.center = vec3(2 - spacing * count++ + u_delta_x, 0+u_delta_y, 4+u_delta_z);//u_delta + 4
  sphere2.radius = rad; 
  sphere2.color = vec3(0.7,0,1);
  sphere2.emissive = vec3(0.0f, 0.0f, 0.0f);


  Sphere sphere3;
  sphere3.center = vec3(2 - spacing * count++, 0, 4);
  sphere3.radius = rad; 
  sphere3.color = vec3(0,0,0.7);
  sphere3.emissive = vec3(0.0f, 0.0f, 0.0f);

  Sphere sphere4;
  sphere4.center = vec3(0, 10, 1);
  sphere4.radius = 10; 
  sphere4.color = vec3(0.1,0.1,0.1);
  sphere4.emissive = vec3(1.0f, 0.9f, 0.7f) * 100.0f;
  world.spheres[0] = sphere4;
  world.spheres[1] = sphere;
  world.spheres[2] = sphere2;
  world.spheres[3] = sphere3;

}
#define MAX_RAY_BOUNCE 8
vec4 runSimulation(Ray camera){
  vec4 pixel = vec4(0);
  vec3 throughput = vec3(1);
  Ray currentRay = camera;
  for(int bounce = 0; bounce < MAX_RAY_BOUNCE; bounce ++){
    HitRecord record;
    record.dist = MISSED_RAY;
    for(int i = 0; i < MAX_OBJECTS; i++){
      hitSphere(currentRay, record, world.spheres[i]);
    }
    if(record.dist == MISSED_RAY) break; //No ray hit

    currentRay.origin = (currentRay.origin + currentRay.direction * record.dist) + record.collisionNormal;
    currentRay.direction = reflect(currentRay.direction, record.collisionNormal);
    //currentRay.direction = normalize(record.collisionNormal + RandomUnitVector(rngState));
    pixel += 0.5*vec4(record.albedo,1);//record.emissive * throughput
    throughput *= record.albedo;



  }

  //Bounce the ray
  

  return pixel;
}


void main() {
  // base pixel colour for image
  vec4 pixel = vec4(0.2, 0.2, 0.3, 1);

  // get index in global work group i.e x,y position
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  ivec2 dims = imageSize(img_output); // fetch image dimensions
  vec2 uv = (pixel_coords - 0.5 * dims) / dims.y;
  rngState= uint(uint(uv.x) * uint(1973) + uint(uv.y) * uint(9277) * uint(26699)) | uint(1);
  Ray camera;
  camera.origin = vec3(0, 0, -2);
  camera.direction = normalize(vec3(uv.x, uv.y, 1.0));

  initWorld();

  pixel = runSimulation(camera);

  
  // output to a specific pixel in the image
  imageStore(img_output, pixel_coords, pixel);
}






















vec3 reflect(vec3 v, vec3 n) {
    return v - 2*dot(v,n)*n;
}



vec3 random_in_unit_sphere() {
    while (true) {
        vec3 p = random();
        p = p / length(p);
        if (p.x*p.x + p.y*p.y + p.z*p.z  >= 1) continue;
        return p;
    }
}
vec3 random(){
  vec2 co = gl_GlobalInvocationID.xy;
  co.x=1;co.y=2;
  return vec3(rand(co));

}

precise float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
uint wang_hash(inout uint seed)
 {
     seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
     seed *= uint(9);
     seed = seed ^ (seed >> 4);
     seed *= uint(0x27d4eb2d);
     seed = seed ^ (seed >> 15);
     return seed;
 }
precise float RandomFloat01(inout uint state)
 {
     return float(wang_hash(state)) / 4294967296.0;
 }
vec3 RandomUnitVector(inout uint state)
 {
     precise float z = RandomFloat01(state) * 2.0f - 1.0f;
     precise float a = RandomFloat01(state) * (2*3.14159);
     precise float r = sqrt(1.0f - z * z);
     precise float x = r * cos(a);
     precise float y = r * sin(a);
     return vec3(x, y, z);
 }