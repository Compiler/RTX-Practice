#version 430

layout(local_size_x = 1, local_size_y = 1) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

layout (std430, binding=2) buffer shader_data
{ 
  vec4 camera_position;
};

uniform precise float u_delta_x;
uniform precise float u_delta_y;
uniform precise float u_delta_z;


uint rngState;

//prototypes
precise float rand(vec2 co);
vec3 random();
vec3 random_in_hemisphere(vec3 normal);
vec3 random_in_unit_sphere(uint state);
uint wang_hash(inout uint seed);
precise float RandomFloat01(inout uint state);
vec3 RandomUnitVector(inout uint state);


//data
struct Metal{
  float fuzz;

};
struct Sphere{
  vec3 center;
  vec3 color;
  precise float radius;
  vec3 emissive;
  bool isMetal;


};

struct Ray{
  vec3 origin;
  vec3 direction;

};

#define MAX_OBJECTS 4
#define MAX_RAY_DEPTH 50
#define NO_HIT_COLOR vec4(0.3, 0.3, 0.4, 1)
#define MAX_RAY_DIST 1000000000
#define MIN_RAY_DIST 0.001
struct World{
  Sphere[MAX_OBJECTS] spheres;

};

struct HitRecord{
  vec3 collisionPoint;
  vec3 collisionNormal;
  precise float dist;
  bool frontFacing;
  vec3 albedo;
  vec3 emissive;

};
World world;


bool hitSphere(Ray ray, inout HitRecord record, Sphere sphere){
  precise float t = dot(sphere.center-ray.origin, ray.direction);
  vec3 collisionPoint = ray.origin + ray.direction*t;

  precise float y = length(sphere.center-collisionPoint);
  if(y < sphere.radius){
    float x = sqrt(sphere.radius*sphere.radius - y*y);
    float t1 = t-x;
    float t2 = t+x;
    if(t1 > MIN_RAY_DIST && t1 < MAX_RAY_DIST){
      collisionPoint = ray.origin + ray.direction*t1;
      vec3 N = collisionPoint - sphere.center;
      record.collisionNormal = normalize(collisionPoint - sphere.center);
      record.collisionPoint = collisionPoint;
      record.dist = t;
      record.frontFacing = dot(ray.direction, record.collisionNormal) < 0;
      if(!record.frontFacing) record.collisionNormal = -record.collisionNormal;
      record.albedo = sphere.color;
      record.emissive = sphere.emissive;
    }
    else if(t2 > MIN_RAY_DIST && t2 < MAX_RAY_DIST){
      collisionPoint = ray.origin + ray.direction*t2;
      vec3 N = collisionPoint - sphere.center;
      record.collisionNormal = normalize(collisionPoint - sphere.center);
      record.collisionPoint = collisionPoint;
      record.dist = t;
      record.frontFacing = dot(ray.direction, record.collisionNormal) < 0;
      if(!record.frontFacing) record.collisionNormal = -record.collisionNormal;
      record.albedo = sphere.color;
      record.emissive = sphere.emissive;
    }
    return true;
  }
  // vec3 unit_direction = ray.direction / length(ray.direction);
  // t = 0.5*(unit_direction.y + 1.0);
  // pixel = vec4((1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0), 1);
  return false;
}



void initWorld(){ 
  precise float rad = 0.5;
  precise float spacing = 1;
  int count = 1;
  Sphere sphere;
  sphere.center = vec3(2 - spacing * count++, 0, 4);
  sphere.radius = rad; 
  sphere.color = vec3(0,1,0);
  sphere.emissive = vec3(0.0f, 0.0f, 0.0f);

  Sphere sphere2;
  sphere2.center = vec3(2 - spacing * count++ + u_delta_x, 0+u_delta_y, 4+u_delta_z);//u_delta + 4
  sphere2.radius = rad; 
  sphere2.color = vec3(1,0,0);
  sphere2.emissive = vec3(0.0f, 0.0f, 0.0f);


  Sphere sphere3;
  sphere3.center = vec3(2 - spacing * count++, 0, 4);
  sphere3.radius = rad; 
  sphere3.color = vec3(0,0,1);
  sphere3.emissive = vec3(0.0f, 0.0f, 0.0f);

  Sphere sphere4;
  sphere4.center = vec3(0, 10, 1);
  sphere4.radius = 9.75; 
  sphere4.color = vec3(0.7, 0.5, 0.3);
  sphere4.color = vec3(0.1);
  sphere4.emissive = vec3(1.0f, 0.9f, 0.7f) * 100.0f;
  world.spheres[0] = sphere4;
  world.spheres[3] = sphere2;
  world.spheres[2] = sphere;
  world.spheres[1] = sphere3;
  // for(int i = 0; i < MAX_OBJECTS; i++){
  //   int minZIndex = i;
  //   for(int j = i; j < MAX_OBJECTS; j++){
  //     if(world.spheres[j].center.z >= world.spheres[minZIndex].center.z) minZIndex = j;
  //   }
  //   Sphere tmp = world.spheres[i];
  //   world.spheres[i] = world.spheres[minZIndex];
  //   world.spheres[minZIndex] = tmp;
  // }


}
#define MAX_RAY_BOUNCE 200

uniform float u_stx;
uniform float u_sty;
uniform float u_stz;


vec4 runSimulation(Ray camera){
  vec4 pixel = vec4(0);
  vec3 throughput = vec3(1);
  Ray currentRay = camera;
  vec3 unit_direction = normalize(currentRay.direction);
  float t = 0.5*(unit_direction.y + 1.0);
  pixel = vec4((1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0), 1);
  bool hit;
  for(int bounce = 0; bounce < MAX_RAY_BOUNCE; bounce ++){
    HitRecord record;
    record.dist = MAX_RAY_DIST;
    for(int i = 0; i < MAX_OBJECTS; i++){
      if(!hitSphere(currentRay, record, world.spheres[i])){
        vec3 unit_direction = normalize(currentRay.direction);
        float t = 0.5*(unit_direction.y + 1.0);
        pixel *= vec4((1.0-t)*vec3(1.0, 1.0, 1.0) + t*vec3(0.5, 0.7, 1.0), 1);
      }else hit = true;
    }
    if(record.dist == MAX_RAY_DIST) break; //No ray hit
    currentRay.origin = record.collisionPoint;

    //LAMBERTIAN DIFFUSE
    //currentRay.direction = currentRay.origin - (record.collisionNormal + random_in_hemisphere(record.collisionNormal));
    //pixel += 0.5*vec4(record.albedo,1);

    //METAL
     vec3 reflected = reflect(currentRay.direction, record.collisionNormal) + vec3(u_stx, u_sty, u_stz);
     if(dot(reflected, record.collisionNormal) > 0){
       currentRay.direction = reflected;
       pixel += 0.5*vec4(0.5*record.albedo,1);
     }


  }

  if(pixel == vec4(0,0,0,0)){
    
  }
  return pixel;
}


void main() {
  // base pixel colour for image
  vec4 pixel = vec4(0.2, 0.2, 0.3, 1);

  // get index in global work group i.e x,y position
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
  ivec2 dims = imageSize(img_output); // fetch image dimensions
  vec2 jitter = vec2(RandomFloat01(rngState), RandomFloat01(rngState)) - 0.5f;
  vec2 uv = (pixel_coords+ jitter - 0.5 * dims) / dims.y;
  rngState= uint(uint(uv.x) * uint(1973) + uint(uv.y) * uint(9277) * uint(26699)) | uint(1);
  Ray camera;
  camera.origin = vec3(0, 0, 0);
  camera.direction = normalize(vec3(uv, 1.0));
  

  initWorld();

  pixel = runSimulation(camera);

  
  // output to a specific pixel in the image
  imageStore(img_output, pixel_coords, pixel);
}






















vec3 reflect(vec3 v, vec3 n) {
    return v - 2*dot(v,n)*n;
}


vec3 random_in_hemisphere(vec3 normal) {
    vec3 in_unit_sphere = random_in_unit_sphere(rngState);
    if (dot(in_unit_sphere, normal) > 0.0) // In the same hemisphere as the normal
        return in_unit_sphere;
    else
        return -in_unit_sphere;
}
vec3 random_in_unit_sphere(uint state) {
    while (true) {
        vec3 p = vec3(RandomFloat01(state), RandomFloat01(state), RandomFloat01(state));
        p = p / length(p);
        if (p.x*p.x + p.y*p.y + p.z*p.z  >= 1) continue;
        return p;
    }
}
vec3 random(){
  vec2 co = gl_GlobalInvocationID.xy;
  co.x=1;co.y=2;
  return vec3(rand(co));

}

precise float rand(vec2 co){
    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
}
uint wang_hash(inout uint seed)
 {
     seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));
     seed *= uint(9);
     seed = seed ^ (seed >> 4);
     seed *= uint(0x27d4eb2d);
     seed = seed ^ (seed >> 15);
     return seed;
 }
precise float RandomFloat01(inout uint state)
 {
     return float(wang_hash(state)) / 4294967296.0;
 }
vec3 RandomUnitVector(inout uint state)
{
    precise float z = RandomFloat01(state) * 2.0f - 1.0f;
    precise float a = RandomFloat01(state) * (2*3.14159);
    precise float r = sqrt(1.0f - z * z);
    precise float x = r * cos(a);
    precise float y = r * sin(a);
    return vec3(x, y, z);
}